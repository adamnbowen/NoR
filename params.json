{"tagline":"There's No Return. A javascript reactive programming engine.","body":"# NoR - There's No Return.\r\n\r\nA reactive programming engine for javascript.\r\n\r\n## Getting Started\r\n\r\nSo what's `NoR` about?, well, simply put it's just my take at what I\r\nlearned to be `reactive programming` yet i'm not an expert at all.\r\n\r\nEven though the term `reactive` might seem like unknown, most of us\r\nalready interact with a reactive system all the time.\r\n\r\nWhen you open your spreadsheet program and start using formulas that\r\nuse values from other cells, you can observe that if you change a\r\nvalue in one of that cells all other cells that depend on it get\r\nupdated accordingly, well, spreadsheets are one example of\r\n`reactive programming`.\r\n\r\nIf you ever played around with protoboards and logic gates, you can\r\nrecall that you used to connect all those little gates to achieve\r\nsomething, say a counter, a clock or any other digital system, well,\r\nthat's also `reactive`, as soon as you connect all the pieces and\r\nthrow a little voltage at it, you get it to work (or not :D).\r\n\r\nIn our days, we see `reactive` systems all around, in recent web\r\ndevelopment people are using more and more javascript, and as many\r\nof us have found, front-end development is almost always enterely\r\nevent based, that is, when something changes, you have to `react`.\r\nA lot of libraries handle reacting to changes, from using\r\n[jQuery][jquery] to act upon a browser event, [Backbone.js][backbone]\r\nand [Knockout.js][knockout] to bind your view and model, etc.\r\n\r\n[jquery]: http://jquery.com\r\n[knockout]: http://knokoutjs.com\r\n[backbone]: http://backbone.org\r\n\r\n## There's No Return\r\n\r\nOk, so imagine you build a little logic gate (the [NOR gate][nor])\r\n\r\n![The NOR logic gate](http://upload.wikimedia.org/wikipedia/commons/c/c6/NOR_ANSI_Labelled.svg)\r\n\r\nIf we try to implement it on javascript, provably it would be like this:\r\n\r\n```javascript\r\nvar NOR = function(a, b){\r\n  var q = !(a || b); // just for you to see a, b and q\r\n  return q;\r\n}\r\n```\r\n\r\nso far so good, well, implementing the `NOR` gate is a trivial\r\nprogram. But what happens with more complex functions that can\r\npossibly fail, in you javascript programming, have you ever seen\r\nfunctions like the following?:\r\n\r\n```javascript\r\nvar complex = function(some, thing){\r\n   // if everything goes fine, we return a value\r\n   // otherwise the make function will just\r\n   // throw an exception, how else do we handle failure?\r\n   return make(some, thing, strange)\r\n}\r\n```\r\n\r\nthe bad thing about functions like this is that its users need to\r\nknow that it can possibly throw an exception as means of handling\r\nfailure, (would you really throw an exception just because some value\r\ndoesnt have the form you expected? please dont!). To fix this, most\r\npeople give the complex function a callback (or a pair of callbacks)\r\nto be called on success and/or error.\r\n\r\n```javascript\r\nvar complex = function(some, thing, callback){\r\n   if(everythingGoesFine) {\r\n     callback(successValue, null)\r\n   } else {\r\n     callback(null, errorValue)\r\n   }\r\n}\r\n```\r\n\r\nYou see? now *There's No Return*. All the function does is do its\r\namazing stuff and invoke the callback accordingly. But again as user\r\nof this function you need to know that callback can take two arguments\r\nand not just only one, or you can make the complex function take two\r\ncallbacks one for success and one for error. That is a callback for\r\neach output the function can have.\r\n\r\nHow does this all relates to `NoR` and `reactive programming`?, read on.\r\n\r\n[nor]: http://en.wikipedia.org/wiki/NOR_logic\r\n\r\n## Reacting to change\r\n\r\nSuppose we try to implement our `NOR` logic gate again wihout using\r\nreturn.\r\n\r\n```javascript\r\nvar NOR = function(a, b, q) {\r\n  q( !( a || b ) )\r\n}\r\n```\r\n\r\nSo now our function takes two values `a` and `b` and a callback\r\nfunction `q`. *Every time you invoke* this function you give it two\r\nvalues and maybe a different callback. It doenst still reacts to\r\nchange automatically, whenever the value of `a` or `b` change you\r\nhave to apply them to the function.\r\n\r\nThe logic gates (or the spreadsheet formulas) react to changes on\r\ntheir input, and automatically produce a new value for them.\r\n\r\nNow image our same NOR implementation, but this time with `a` and\r\n`b` also being functions. These functions if given no arguments just\r\ngive you the current *state* of each input, and our function looks like:\r\n\r\n```javascript\r\nvar NOR = function(a, b, q) {\r\n  q( !( a() || b() ) )\r\n}\r\n```\r\n\r\n## How does it works\r\n\r\nUsing the `NoR` function to create a *gate* that reacts\r\nto changes on its inputs, and our NOR gate is:\r\n\r\n```javascript\r\nvar NOR = NoR(function(a, b, q){\r\n  q( !( a() || b() ) )\r\n})\r\n```\r\n\r\nLooks pretty much like our previous implementation, the only\r\ndifference being that the function is wrapped with `NoR`.\r\nWhat `NoR` does is creating a *cell* for each function parameter.\r\n\r\nA *cell* is just something that looks like a function and serves to\r\nhold a value. When a cell is given no arguments, it just returns its\r\ncurrent value, but when an argument is given to it, it sets its new\r\nvalue and notifies everyone interested on that cell of its change.\r\n\r\nIn our example, `a`, `b` and `c` are cells, but only the first two are\r\nused as inputs, the third as an output.\r\n\r\nThe return value of the `NoR` function also looks like a function:\r\n\r\n```\r\n; setting a = false b = true\r\nNOR(false, true) ; => undefined\r\n```\r\n\r\nHowever it doesnt act as one of those functions that return values or\r\naccept callbacks. What we have just did is simply setting the `a` *cell*\r\nto `true` and the `b` *cell* to `false`. The result of the operation is\r\nasynchronous, that is, we cant be sure in what exact second we have the\r\nresponse.\r\n\r\nJust like with *promises* we have something that represents a value in\r\nthe future, we dont know exactly when, but it *will* hold the response\r\nvalue.\r\n\r\nSo what we do for using the value of `c` is to listen for changes\r\non `c` by *subscribing* to it.\r\n\r\nFor example:\r\n\r\n```javascript\r\nNOR.c.subscribe(function(newC){\r\n  console.log(\"OK, the new value of c is\", newC)\r\n})\r\n\r\nNOR.b(false) // here we are changing the value of the b cell\r\n\r\n// sometime in the future we see\r\n// a message printed to stdout.\r\n```\r\n\r\nThe `NoR` function form is:\r\n\r\n```javascript\r\nNoR(gate, wiring, self)\r\n```\r\n\r\nWhere `gate` is a function that receives *cells* and is invoked\r\nwhenever one of them changes. An `wiring` function can be specified\r\nthat receives the same *cells* than `gate` for the sake of setting up\r\ncell subscriptions or creating inner gates. If a value for\r\n`self` if given it will be wrapped on an special *cell* named\r\n`self` and its value will be used as `this` whenever `gate` gets\r\ncalled, of course changing the gate's self will trigger its evaluation.\r\n\r\nFor example, to build an `XOR` gate using just the universal `NOR`\r\ngate, you can do:\r\n\r\n![Implementing a XNOR gate using NOR gates](http://upload.wikimedia.org/wikipedia/commons/f/f8/XNOR_using_NOR.svg)\r\n\r\n```javascript\r\n\r\n// The universal NOR logic gate.\r\nvar NOR = NoR(function(a, b, g){\r\n  g( !( a() || b() ) )\r\n})\r\n\r\n// the gate has no implementation as it's actually\r\n// the result of the combination of several NOR gates\r\n// and their outputs. We wire all of them on\r\n// the setup function.\r\n//\r\n// Note that the XNOR gate exposes just three ports:\r\n// a, b and q.\r\n//\r\n// However the gates wired inside use some others like\r\n// x, m and n. Follow the image above.\r\nvar XNOR = NoR(function(a, b, q){}, function(a, b, x, m, n, q){\r\n  // Using the new operator on a gate\r\n  // simply cretes a copy of that gate\r\n  // and we assign each its ports.\r\n  new NOR(a, b, x)\r\n  new NOR(a, x, m)\r\n  new NOR(b, x, n)\r\n  new NOR(m, n, q)\r\n})\r\n\r\n```\r\n\r\n### On the server\r\nInstall the module with: `npm install NoR`\r\n\r\n```javascript\r\nvar NoR = require('NoR');\r\nNoR.awesome(); // \"awesome\"\r\n```\r\n\r\n### In the browser\r\nDownload the [production version][min] or the [development version][max].\r\n\r\n[min]: https://raw.github.com/vic/NoR/master/dist/NoR.min.js\r\n[max]: https://raw.github.com/vic/NoR/master/dist/NoR.js\r\n\r\nIn your web page:\r\n\r\n```html\r\n<script src=\"dist/NoR.min.js\"></script>\r\n```\r\n\r\n## Documentation\r\n\r\nUse our [wiki][wiki].\r\n\r\n[wiki]: https://github.com/vic/NoR/wiki\r\n\r\n## Examples\r\n\r\nSee the [examples/][examples] directory and try running some of them.\r\n\r\n```shell\r\n$ node examples/ten_times.js\r\n```\r\n\r\nAn example on how to implement a [JK flip-flop][jk] can be found [here][jke]\r\n\r\n![JK flip flip](http://hyperphysics.phy-astr.gsu.edu/hbase/electronic/ietron/jk2.gif)\r\n\r\n[jk]: http://hyperphysics.phy-astr.gsu.edu/hbase/electronic/jkflipflop.html#c2\r\n[examples]: https://github.com/vic/NoR/tree/master/examples\r\n[jke]: https://github.com/vic/NoR/blob/master/examples/jk-flipflop.js\r\n\r\n## Contributing\r\n\r\nAll contributions are welcome, of course you [fork][fork] the proyect\r\ndo some changes on what you are interested, new features, typos,\r\ntests, examples or anything you want and finally you can send a\r\n[pull request][pulls] and I'll be more than grateful to you.\r\n\r\n[fork]: https://github.com/vic/NoR/fork_select\r\n[pulls]: https://github.com/vic/NoR/pulls\r\n\r\n## Developing\r\n\r\nFirst get a [fork][fork] of `NoR` and install its development\r\ndependencies.\r\n\r\n```shell\r\n$ npm install\r\n```\r\n\r\nTo run specs use the `npm test` command.\r\n\r\n## License\r\nCopyright (c) 2012 Victor Borja\r\nLicensed under the MIT license.\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"UA-33940392-1","name":"NoR"}